"""
``edg_acoustics.mesh``
======================

The edg_acoustics mesh functions and classes provide functionality to process
and access mesh data generated by different mesh generators (e.g.,
`DOLFIN XML <https://manpages.ubuntu.com/manpages/jammy/en/man1/dolfin-convert.1.html>`_ (``.xml``),
`Netgen <https://github.com/ngsolve/netgen>`_ (``.vol``, ``.vol.gz``),
`Gmsh <https://gmsh.info/doc/texinfo/gmsh.html#File-formats>`_ (format versions 2.2, 4.0, and 4.1 ``.msh``)
courtesy of
the `meshio <https://github.com/nschloe/meshio>`_ package.

Please note that the most-used mesh functions and classes in edg_acoustics are present in
the main :mod:`edg_acoustics` namespace rather than in :mod:`edg_acoustics.mesh`.  These are:
:class:`.Mesh`, and :func:`.some_function`.

Functions and classes present in :mod:`edg_acoustics.mesh` are listed below.

Mesh processing
---------------
   Mesh
"""
from __future__ import annotations
import numpy

import meshio

__all__ = ['Mesh']


class Mesh:
    """Mesh data structure generated from common mesh file formats.

    Data structure containing mesh definition. Mesh data is obtained from
    data stored in common mesh file format by
    `Gmsh <https://gmsh.info/doc/texinfo/gmsh.html#File-formats>`_ (format versions 2.2, 4.0, and 4.1 ``.msh``).
    Since mesh reading relies on meshio, other mesh generators can be made available in the future (e.g.,
    `DOLFIN XML <https://manpages.ubuntu.com/manpages/jammy/en/man1/dolfin-convert.1.html>`_ (``.xml``),
    `Netgen <https://github.com/ngsolve/netgen>`_ (``.vol``, ``.vol.gz``).

    :class:`.Mesh` defines the domain discretisation and is used to define
    the finite element approximation of the solution to the acoustic
    wave propagation.

    Args:
        filename (str): the file (pathlike) to read mesh data from. Supported format
            Gmsh (format versions 2.2, 4.0, and 4.1, .msh).
            Since mesh reading relies on meshio, the following formats can be made available in the future:
            Abaqus (.inp), ANSYS msh (.msh), AVS-UCD (.avs), CGNS (.cgns), DOLFIN XML (.xml), Exodus (.e, .exo),
            FLAC3D (.f3grid), H5M (.h5m), Kratos/MDPA (.mdpa), Medit (.mesh, .meshb), MED/Salome (.med),
            Nastran (bulk data, .bdf, .fem, .nas), Netgen (.vol, .vol.gz), Neuroglancer precomputed format,
            Gmsh (format versions 2.2, 4.0, and 4.1, .msh), OBJ (.obj), OFF (.off),
            PERMAS (.post, .post.gz, .dato, .dato.gz), PLY (.ply), STL (.stl), Tecplot .dat, TetGen .node/.ele,
            SVG (2D output only) (.svg), SU2 (.su2), UGRID (.ugrid), VTK (.vtk), VTU (.vtu), WKT (TIN) (.wkt),
            XDMF (.xdmf, .xmf).
        BC_labels (dict[str, int]): a dictionary containing the human readable label of each boundary condition and the
            associated lable number used in the mesh generator. BC_labels['my_label'] returns the label number of the
            label named 'my_label'. If BC_labels['my_label'] is not present in the mesh, an error is raised. If a label
            is present in the mesh but not in BC_labels, an error is raised.

    Raises:
        ValueError: If BC_labels['my_label'] is not present in the mesh, an error is raised. If a label
            is present in the mesh but not in BC_labels, an error is raised.

    Attributes:
        N_vertices (int): The number of vertices that make up the mesh.
        N_tets (int): The number of tetrahedra that make up the mesh (number of elements).
        N_BC_triangles (dict[str, int]): the number of triangles on the boundary of the domain associated to each
            boundary label in self.BC_labels. For example self.N_BC_triangles['my_label'] returns the number of boundary
            triangles associated to lable 'my_label'. 'my_label' must be a key of self.BC_labels.
        vertices (numpy.ndarray): An (self.N_vertices x M) array containing the M coordinates of the self.N_vertices vertices that make up
            the mesh. M specifies the geometric dimension of the mesh, such that the mesh describes an M-dimensional
            domain.
        tets (numpy.ndarray): An (self.N_tets x 4) array containing the 4 indices of the vertices of the self.N_tets
               tetrahedra that make up the mesh.
        BC_triangles (dict[str, numpy.ndarray]):

    Example:
        An element of this class can be initialized in the following way

            >>> import edg_acoustics
            >>> BC_labels = {'CNRBC': 12, 'slip': 11, 'impedance': 33}
            >>> filename = "path_to_my_mesh_file/mesh_filename.msh"
            >>> mesh = edg_acoustics.Mesh(filename, BC_labels)
    """

    def __init__(self, filename: str, BC_labels: dict[str, int]):
        # Init from file
        self.__init_from_file(filename, BC_labels)

    def __init_from_file(self, filename: str, BC_labels: dict[str, int]):
        print("Init from filename")

        # Load mesh data from mesh file
        mesh_data = meshio.read(filename)

        # Extract the relevant data and store it in the object

        # Read the number of points and their coordinates
        self.N_vertices = mesh_data.points.shape[0]
        self.vertices = mesh_data.points

        # Check if all labels provided as input exist in the mesh data and vice versa, if not, raise error
        BC_labels_in_mesh = sorted(numpy.unique(mesh_data.cell_data_dict['gmsh:physical']['triangle']))  # get all labels in the mesh, sort for faster comparison below
        BC_labels_in_input = sorted(BC_labels.values())  # get all labels specified in input
        if not BC_labels_in_input == BC_labels_in_mesh:
            raise ValueError(
                "[edg_acoustics.Mesh] All BC labels must be present in the mesh and all labels in the mesh must be "
                "present in BC_labels.")

        # Read the boundary triangles and their definitions separating them into the different boundary condition labels
        self.N_BC_triangles = dict()
        self.BC_triangles = dict()
        for BC_label in BC_labels:
            triangles_have_label = (mesh_data.cell_data_dict['gmsh:physical']['triangle'] == BC_labels[BC_label])  # array with bools specifying if triangle has BC_label or not
            self.N_BC_triangles[BC_label] = triangles_have_label.sum()  # number of triangles with label BC_label
            self.BC_triangles[BC_label] = mesh_data.cells_dict['triangle'][triangles_have_label]  # get the triangles with BC_label

        # Read the number of tetrahedra (computational elements) and their definitions
        self.N_tets = mesh_data.cells_dict['tetra'].shape[0]
        self.tets = mesh_data.cells_dict['tetra']

    # Properties -------------------------------------------------------------------------------------------------------
    @property
    def EToV(self):
        """numpy.ndarray: An (self.N_tets x 4) array containing the 4 indices of the vertices of the self.N_tets
               tetrahedra that make up the mesh. It returns the value in self.tets, since it is the same data."""
        return self.tets
    # ------------------------------------------------------------------------------------------------------------------


