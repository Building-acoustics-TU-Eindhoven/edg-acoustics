"""
``edg_acoustics.mesh``
======================

The edg_acoustics mesh functions and classes provide functionality to process
and access mesh data generated by different mesh generators (e.g.,
`DOLFIN XML <https://manpages.ubuntu.com/manpages/jammy/en/man1/dolfin-convert.1.html>`_ (``.xml``),
`Netgen <https://github.com/ngsolve/netgen>`_ (``.vol``, ``.vol.gz``),
`Gmsh <https://gmsh.info/doc/texinfo/gmsh.html#File-formats>`_ (format versions 2.2, 4.0, and 4.1 ``.msh``)
courtesy of
the `meshio <https://github.com/nschloe/meshio>`_ package.

Please note that the most-used mesh functions and classes in edg_acoustics are present in
the main :mod:`edg_acoustics` namespace rather than in :mod:`edg_acoustics.mesh`.  These are:
:class:`.Mesh`, and :func:`.some_function`.

Functions and classes present in :mod:`edg_acoustics.mesh` are listed below.

Mesh processing
---------------
   Mesh
"""
from __future__ import annotations
import numpy

import meshio

__all__ = ['Mesh']


class Mesh:
    """Mesh data structure generated from common mesh file formats.

    Data structure containing mesh definition. Mesh data is obtained from
    raw data or from data stored in common mesh file formats by different
    mesh generators (e.g.,
    `DOLFIN XML <https://manpages.ubuntu.com/manpages/jammy/en/man1/dolfin-convert.1.html>`_ (``.xml``),
    `Netgen <https://github.com/ngsolve/netgen>`_ (``.vol``, ``.vol.gz``),
    `Gmsh <https://gmsh.info/doc/texinfo/gmsh.html#File-formats>`_ (format versions 2.2, 4.0, and 4.1 ``.msh``).

    :class:`.Mesh` defines the domain discretisation and is used to define
    the finite element spaces that approximate the solution to the acoustic
    wave propagation.

    If both raw data and filename are given as input, raw data has precedence.

    Args:
        filename (str | None, optional): the file (pathlike) to read mesh data from. Supported formats as in meshio: Abaqus (.inp),
            ANSYS msh (.msh), AVS-UCD (.avs), CGNS (.cgns), DOLFIN XML (.xml), Exodus (.e, .exo), FLAC3D (.f3grid),
            H5M (.h5m), Kratos/MDPA (.mdpa), Medit (.mesh, .meshb), MED/Salome (.med),
            Nastran (bulk data, .bdf, .fem, .nas), Netgen (.vol, .vol.gz), Neuroglancer precomputed format,
            Gmsh (format versions 2.2, 4.0, and 4.1, .msh), OBJ (.obj), OFF (.off),
            PERMAS (.post, .post.gz, .dato, .dato.gz), PLY (.ply), STL (.stl), Tecplot .dat, TetGen .node/.ele,
            SVG (2D output only) (.svg), SU2 (.su2), UGRID (.ugrid), VTK (.vtk), VTU (.vtu), WKT (TIN) (.wkt),
            XDMF (.xdmf, .xmf).
            Required for filename input mode.

        vertices (numpy.ndarray | None, optional): An NxM array containing the M coordinates of the N vertices that make up
            the mesh. M specifies the geometric dimension of the mesh, such that the mesh describes an M-dimensional
            domain.

        cells (dict[str, numpy.ndarray] | None, optional): the definition of cells in the format
            {cell_type_1: cells_of_type_1, cell_type_2: cells_of_type_2, ...}. cell_type_i is a string that may
            take the values 'triangle' or 'tetra'. cell_of_type_i is a numpy.array of size K_i x L_i defining the K_i
            cells of type cell_type_i in the mesh. Contains the indices of the vertices defining the K_i cells of
            type cell_type_i. If cell_type_i is 'triangle' then L_i = 3, if cell_type_i is 'tetra' then L_i = 4.

        vertex_data (dict[str, numpy.ndarray] | None, optional): assigns data to the vertices of the mesh. vertex_data
            has the format {'data_label_1': vertex_data_1, 'data_label_2': vertex_data_2, ...}. data_label_i is a string
            specifying the label of the i-th vertex data set (a name). vertex_data_i is a numpy.ndarray of dimension N
            (number of vertices in the mesh).

        cell_data (dict[str, list[numpy.ndarray]] | None, optional): assigns data to the cells of the mesh. cell_data
            has the format {'data_label_1': [cell_type_1_data_1, cell_type_2_data_1, ...],
            'data_label_2': [cell_type_1_data_2, cell_type_2_data_2, ...], ...}. data_label_i is a string
            specifying the label of the i-th cell data set (a name). cell_type_j_data_i is a numpy.ndarray of dimension
            K_i.

    Raises:
        ValueError: If only one of

    Attributes:
        vertices (numpy.ndarray): An NxM array containing the M coordinates of the N vertices that make up
            the mesh. M specifies the geometric dimension of the mesh, such that the mesh describes an M-dimensional
            domain.

    Example:
        An element of this class can be initialized in the following ways

        From raw data

            >>> import edg_acoustics
            >>> # Define the vertices of the mesh
            >>> vertices = [
                    [0.0, 0.0],
                    [1.0, 0.0],
                    [0.0, 1.0],
                    [1.0, 1.0],
                    [2.0, 0.0],
                    [2.0, 1.0],
                ]
            >>> # Define two triangles
            >>> cells = [("triangle", [[0, 1, 2], [1, 3, 2]])]
            >>> # Generate the mesh
            >>> mesh = edg_acoustics.Mesh(vertices=vertices, cells=cells)

        From file

            >>> import edg_acoustics
            >>> mesh = edg_acoustics.Mesh(filename="path_to_my_mesh_file/mesh_filename.msh")
    """

    def __init__(
        self,
        filename: str | None = None,
        vertices: numpy.ndarray | None = None,
        cells: dict[str, numpy.ndarray] | None = None,
        vertex_data: dict[str, numpy.ndarray] | None = None,
        cell_data: dict[str, list[numpy.ndarray]] | None = None
    ):
        raw_init_required_input_list = [vertices, cells]  # list of required inputs to initialize mesh from raw input

        if all(raw_init_required_input_list):
            self.__init_from_raw_data(vertices, cells, vertex_data, cell_data)  # init from raw data

        elif not (filename is None):
            self.__init_from_file(filename)  # init from file

        else:
            raise ValueError("[edg_acoustics.mesh,Mesh] You must provide raw input (vertices, cells, [point_data, cell_data]) or mesh "
                             "filename from where to read data.")

    def __init_from_raw_data(
        self,
        vertices: numpy.ndarray | None = None,
        cells: dict[str, numpy.ndarray] | None = None,
        point_data: dict[str, numpy.ndarray] | None = None,
        cell_data: dict[str, list[numpy.ndarray]] | None = None
    ):
        mesh = meshio.Mesh(vertices, cells, point_data=point_data, cell_data=cell_data)
        self.vertices = mesh.points

    def __init_from_file(self, filename: str):
        print("Init from filename")
